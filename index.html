<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Flappy Bird Responsive</title>
    <style>
        /* C·∫¨P NH·∫¨T: ƒê·∫∑t t√™n font family l√† 04b_19 cho ƒë√∫ng chu·∫©n */
        @font-face {
            font-family: '04b_19';
            src: url('https://raw.githubusercontent.com/nnam0308/flappybird/refs/heads/main/flappy-font.ttf') format('truetype');
        }

        body {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            background-color: #70c5ce; 
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            /* C·∫¨P NH·∫¨T: S·ª≠ d·ª•ng t√™n font 04b_19 */
            font-family: '04b_19', monospace;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            background-color: #70c5ce;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            image-rendering: pixelated; 
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            text-shadow: 2px 2px 0 #000;
        }

        .score-display {
            position: absolute;
            top: 10%; 
            font-size: 8vh; 
            color: white;
            z-index: 10;
            font-weight: bold;
            /* Text stroke ƒë·ªÉ s·ªë n·ªïi b·∫≠t h∆°n */
            -webkit-text-stroke: 2px #000;
        }

        #start-screen {
            background: transparent;
            padding: 0;
            border: none;
            pointer-events: auto;
            transition: opacity 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #game-over-screen {
            background: transparent;
            border: none;
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2vh; 
        }

        /* C·∫¨P NH·∫¨T: D√πng clamp() ƒë·ªÉ co gi√£n m∆∞·ª£t m√† */
        
        #go-title {
            /* Min: 250px (Mobile), Th√≠ch h·ª£p: 18.3vw, Max: 350px (PC) */
            width: clamp(250px, 18.3vw, 350px);
            image-rendering: pixelated;
            opacity: 0; 
            transform: translateY(-20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }

        #go-board-container {
            position: relative;
            /* Min: 300px, Th√≠ch h·ª£p: 23.5vw, Max: 450px */
            width: clamp(300px, 23.5vw, 450px);
            aspect-ratio: 113/57; 
            opacity: 0; 
            transform: translateY(20px);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }

        #go-board-img {
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }

        /* Font size co gi√£n theo b·∫£ng ƒëi·ªÉm */
        .board-text {
            position: absolute;
            right: 12%;
            color: #fff;
            /* C·∫¨P NH·∫¨T: S·ª≠ d·ª•ng t√™n font 04b_19 */
            font-family: '04b_19', monospace;
            /* Co gi√£n font ch·ªØ theo b·∫£ng ƒëi·ªÉm */
            font-size: clamp(22px, 2.1vw, 40px); 
            text-align: right;
            width: 50%;
            -webkit-text-stroke: 1px #000;
        }

        #board-score { top: 32%; }
        #board-best { top: 72%; }

        #board-medal {
            position: absolute;
            left: 13%;
            top: 43%;
            width: 20%;
            height: 40%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(30px, 2.6vw, 50px); 
        }

        button {
            background-color: #e94b28;
            border: 2px solid #fff;
            color: white;
            /* Padding v√† font c≈©ng co gi√£n nh·∫π */
            padding: 1vh 3vw;
            font-size: clamp(18px, 1.5vw, 28px);
            /* C·∫¨P NH·∫¨T: S·ª≠ d·ª•ng t√™n font 04b_19 */
            font-family: '04b_19', monospace;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 2px 2px 0 #000;
            margin-top: 10px;
            opacity: 0; 
            transition: opacity 0.5s, transform 0.1s;
        }

        button:active { transform: scale(0.95); }
        .hidden { display: none !important; }
        .visible { opacity: 1 !important; transform: translateY(0) !important; }

        @keyframes shake {
            0% { transform: translate(0, 0); }
            10% { transform: translate(-5px, -5px); }
            20% { transform: translate(5px, 5px); }
            30% { transform: translate(-5px, 5px); }
            40% { transform: translate(5px, -5px); }
            50% { transform: translate(0, 0); }
        }
        .shake { animation: shake 0.4s linear; }
        .fade-out { opacity: 0 !important; pointer-events: none; }

        #fps-counter {
            position: absolute;
            top: 10px;
            right: 15px;
            color: #00ff00;
            font-size: 16px;
            font-weight: bold;
            z-index: 20;
            text-shadow: 2px 2px 0 #000;
            /* Font s·∫Ω k·∫ø th·ª´a t·ª´ body (04b_19) */
        }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        
        <div id="ui-layer">
            <div id="fps-counter">FPS: 60</div>
            <div id="score" class="score-display">0</div>

            <div id="start-screen">
                <img src="https://i.ibb.co/3yGTnnNR/message.png" 
                     alt="Get Ready" 
                     style="width: 40vh; max-width: 80vw; image-rendering: pixelated;">
            </div>

            <div id="game-over-screen" class="hidden">
                <img id="go-title" src="https://i.ibb.co/prRnvtb3/game-over.png" alt="Game Over">
                
                <div id="go-board-container">
                    <img id="go-board-img" src="https://i.ibb.co/Mx9Dr83P/results.png" alt="Results">
                    <div id="board-medal"></div>
                    <div id="board-score" class="board-text">0</div>
                    <div id="board-best" class="board-text">0</div>
                </div>

                <button id="btn-restart">Ch∆°i l·∫°i</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        let GAME_WIDTH = window.innerWidth;
        let GAME_HEIGHT = window.innerHeight;
        let scale = 1; 

        // --- C·∫¨P NH·∫¨T: TH√äM √ÇM THANH ---
        const flapSound = new Audio('https://github.com/nnam0308/flappybird/raw/refs/heads/main/audio/wing.mp3');
        const pointSound = new Audio('https://github.com/nnam0308/flappybird/raw/refs/heads/main/audio/point.mp3');
        // √Çm thanh khi ch·∫øt v√† hi·ªán b·∫£ng ƒëi·ªÉm
        const hitSound = new Audio('https://github.com/nnam0308/flappybird/raw/refs/heads/main/audio/hit.mp3'); 
        const dieSound = new Audio('https://github.com/nnam0308/flappybird/raw/refs/heads/main/audio/die.mp3');
        const swooshSound = new Audio('https://github.com/nnam0308/flappybird/raw/refs/heads/main/audio/swooshing.mp3');

        const bgDayImg = new Image();
        bgDayImg.src = 'https://i.ibb.co/KpL6Fswd/background-day.png';
        const bgNightImg = new Image();
        bgNightImg.src = 'https://i.ibb.co/v4KQSbZP/background-night.png';
        let currentBgImg = Math.random() < 0.5 ? bgDayImg : bgNightImg;

        const pipeImg = new Image();
        pipeImg.src = 'https://raw.githubusercontent.com/samuelcust/flappy-bird-assets/refs/heads/master/sprites/pipe-green.png';
        const groundImg = new Image();
        groundImg.src = 'https://github.com/samuelcust/flappy-bird-assets/blob/master/sprites/base.png?raw=true';
        
        const birdImgUp = new Image(); 
        birdImgUp.src = 'https://github.com/samuelcust/flappy-bird-assets/blob/master/sprites/yellowbird-upflap.png?raw=true';
        const birdImgMid = new Image(); 
        birdImgMid.src = 'https://github.com/samuelcust/flappy-bird-assets/blob/master/sprites/yellowbird-midflap.png?raw=true';
        const birdImgDown = new Image(); 
        birdImgDown.src = 'https://github.com/samuelcust/flappy-bird-assets/blob/master/sprites/yellowbird-downflap.png?raw=true';

        let frames = 0;
        let score = 0;
        let highScore = localStorage.getItem('flappy_highscore') || 0;
        let gameState = 'START'; 
        let gameSpeed = 3.5; 

        const background = {
            x: 0,
            draw: function() {
                ctx.fillStyle = "#70c5ce"; 
                ctx.fillRect(0,0, GAME_WIDTH, GAME_HEIGHT);
                if (currentBgImg.complete && currentBgImg.naturalWidth !== 0) {
                    const imgH = currentBgImg.naturalHeight || 512;
                    const imgW = currentBgImg.naturalWidth || 288;
                    const ratio = GAME_HEIGHT / imgH;
                    const drawW = imgW * ratio;
                    const drawH = GAME_HEIGHT;
                    const count = Math.ceil(GAME_WIDTH / drawW) + 1;
                    for(let i=0; i<count; i++) {
                        ctx.drawImage(currentBgImg, this.x + i * drawW, 0, drawW, drawH);
                    }
                }
            },
            update: function() { }
        };

        const ground = {
            height: 112,
            x: 0,
            draw: function() {
                if (groundImg.complete && groundImg.naturalWidth !== 0) {
                    let imgH = groundImg.naturalHeight || 112;
                    let imgW = groundImg.naturalWidth || 336;
                    let ratio = this.height / imgH;
                    let drawW = imgW * ratio;
                    let count = Math.ceil(GAME_WIDTH / drawW) + 1;
                    for (let i = 0; i < count; i++) {
                        ctx.drawImage(groundImg, this.x + i * drawW, GAME_HEIGHT - this.height, drawW, this.height);
                    }
                } else {
                    ctx.fillStyle = "#ded895";
                    ctx.fillRect(0, GAME_HEIGHT - this.height, GAME_WIDTH, this.height);
                }
            },
            update: function() {
                if (gameState === 'PLAYING' || gameState === 'START') {
                    this.x -= gameSpeed;
                    let imgW = groundImg.naturalWidth || 336;
                    let ratio = this.height / (groundImg.naturalHeight || 112);
                    let tileWidth = imgW * ratio;
                    if (this.x <= -tileWidth) this.x += tileWidth;
                }
            }
        };

        const bird = {
            x: 200, y: 0, 
            baseRadius: 18, radius: 18,
            baseWidth: 51, width: 51,
            baseHeight: 36, height: 36,
            velocity: 0,
            baseGravity: 0.25, gravity: 0.25,
            baseJump: 6.5, jump: 6.5,
            rotation: 0,
            animation: [birdImgUp, birdImgMid, birdImgDown, birdImgMid], 
            frame: 0, frameTimer: 0,
            
            draw: function() {
                let sprite = this.animation[this.frame];
                ctx.save();
                ctx.translate(this.x, this.y);
                this.rotation = Math.min(Math.PI / 2, Math.max(-25 * Math.PI / 180, (this.velocity * 0.12)));
                if(gameState === 'START') this.rotation = 0;
                ctx.rotate(this.rotation);

                if (sprite && sprite.complete && sprite.naturalWidth !== 0) {
                    ctx.drawImage(sprite, -this.width / 2, -this.height / 2, this.width, this.height);
                } else {
                    ctx.fillStyle = "#f48024";
                    ctx.beginPath();
                    ctx.arc(0, 0, this.radius, 0, Math.PI*2);
                    ctx.fill();
                    ctx.stroke();
                }
                ctx.restore();
            },
            
            update: function() {
                let isDiving = this.rotation > Math.PI / 4; 
                if ((gameState === 'START' || gameState === 'PLAYING') && !isDiving) {
                    this.frameTimer++;
                    if (this.frameTimer % 5 === 0) this.frame = (this.frame + 1) % 4; 
                } else if (isDiving) {
                    this.frame = 1; 
                }

                if (gameState === 'START') {
                    let flightZoneCenter = (GAME_HEIGHT - ground.height) / 2;
                    this.y = flightZoneCenter + Math.sin(frames * 0.05) * (10 * scale);
                    this.velocity = 0;
                } else if (gameState === 'PLAYING' || gameState === 'OVER') {
                    this.velocity += this.gravity;
                    this.y += this.velocity;
                    if (this.y + this.radius >= GAME_HEIGHT - ground.height) {
                        this.y = GAME_HEIGHT - ground.height - this.radius;
                        if(gameState === 'PLAYING') gameOver(false);
                    }
                    if(this.y - this.radius <= 0) {
                        this.y = this.radius;
                        this.velocity = 0;
                    }
                }
            },
            // C·∫¨P NH·∫¨T: Ph√°t √¢m thanh khi v·ªó c√°nh
            flap: function() { 
                this.velocity = -this.jump; 
                flapSound.currentTime = 0;
                flapSound.play().catch(e => console.log("Audio play blocked", e));
            }
        };

        const pipes = {
            position: [],
            width: 100, gap: 200, spacing: 300, dx: 0,
            draw: function() {
                for(let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    let topY = p.y;
                    let bottomY = p.y + this.gap;
                    if (pipeImg.complete && pipeImg.naturalWidth !== 0) {
                        let drawHeight = GAME_HEIGHT; 
                        ctx.save();
                        ctx.translate(p.x, topY);
                        ctx.scale(1, -1); 
                        ctx.drawImage(pipeImg, 0, 0, this.width, drawHeight);
                        ctx.restore();
                        ctx.drawImage(pipeImg, p.x, bottomY, this.width, drawHeight);
                    } else {
                        ctx.fillStyle = "#73bf2e";
                        ctx.fillRect(p.x, 0, this.width, topY); 
                        ctx.fillRect(p.x, bottomY, this.width, GAME_HEIGHT - ground.height - bottomY); 
                    }
                }
            },
            update: function() {
                if (gameState !== 'PLAYING') return;
                if(this.position.length === 0 || (GAME_WIDTH - this.position[this.position.length - 1].x >= this.spacing)) {
                    let minPipeLen = 50 * scale;
                    let maxPos = GAME_HEIGHT - ground.height - this.gap - minPipeLen;
                    let minPos = minPipeLen;
                    if (maxPos < minPos) maxPos = minPos;
                    let randomY = Math.floor(Math.random() * (maxPos - minPos + 1) + minPos);
                    this.position.push({ x: GAME_WIDTH, y: randomY, passed: false });
                }
                for(let i = 0; i < this.position.length; i++) {
                    let p = this.position[i];
                    p.x -= this.dx;
                    let hitX = 5 * scale;
                    let hitY = 5 * scale;
                    if(bird.x + bird.radius - hitX > p.x && bird.x - bird.radius + hitX < p.x + this.width) {
                        // C·∫¨P NH·∫¨T: G·ªçi gameOver v·ªõi tham s·ªë true (ch·∫°m ·ªëng -> ph√°t die.mp3)
                        if(bird.y - bird.radius + hitY < p.y || bird.y + bird.radius - hitY > p.y + this.gap) gameOver(true);
                    }
                    if(p.x + this.width < bird.x && !p.passed) {
                        score++;
                        document.getElementById('score').innerText = score;
                        p.passed = true;

                        // C·∫¨P NH·∫¨T: Ph√°t √¢m thanh khi ghi ƒëi·ªÉm
                        pointSound.currentTime = 0;
                        pointSound.play().catch(e => console.log("Audio play blocked", e));
                    }
                    if(p.x + this.width <= -this.width) { this.position.shift(); i--; }
                }
            },
            reset: function() { this.position = []; this.dx = gameSpeed; }
        };

        function resize() {
            GAME_WIDTH = window.innerWidth;
            GAME_HEIGHT = window.innerHeight;
            canvas.width = GAME_WIDTH;
            canvas.height = GAME_HEIGHT;
            ctx.imageSmoothingEnabled = false; 

            scale = Math.min(GAME_WIDTH / 400, GAME_HEIGHT / 720); 
            if (scale < 0.6) scale = 0.6;

            gameSpeed = 3.5 * scale;
            pipes.dx = gameSpeed;
            ground.height = 112 * scale;
            bird.width = bird.baseWidth * scale;
            bird.height = bird.baseHeight * scale;
            bird.radius = bird.baseRadius * scale;
            bird.gravity = bird.baseGravity * scale;
            bird.jump = bird.baseJump * scale;
            bird.x = GAME_WIDTH * 0.2; 
            pipes.width = 100 * scale; 
            pipes.gap = 200 * scale;   
            pipes.spacing = 350 * scale; 

            if (gameState === 'START') bird.y = (GAME_HEIGHT - ground.height) / 2;
        }

        window.addEventListener('resize', resize);
        resize();

        function init() { requestAnimationFrame(loop); }
        let lastFpsTime = 0;
        let frameCount = 0;
        function loop(timestamp) { 
            update(); draw(); 
            if (!lastFpsTime) lastFpsTime = timestamp;
            else {
                frameCount++;
                if (timestamp - lastFpsTime >= 1000) {
                    document.getElementById('fps-counter').innerText = 'FPS: ' + frameCount;
                    frameCount = 0;
                    lastFpsTime = timestamp;
                }
            }
            requestAnimationFrame(loop); 
        }

        function update() {
            background.update();
            pipes.update();
            ground.update();
            bird.update();
            if(gameState === 'PLAYING' || gameState === 'START') frames++;
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            background.draw();
            pipes.draw();
            ground.draw();
            bird.draw();
        }

        function startGame() {
            gameState = 'PLAYING';
            const startScreen = document.getElementById('start-screen');
            startScreen.classList.add('fade-out');
            setTimeout(() => { startScreen.classList.add('hidden'); }, 300);
            document.getElementById('score').classList.remove('hidden');
            document.getElementById('game-over-screen').classList.add('hidden');
            score = 0;
            document.getElementById('score').innerText = score;
            bird.flap(); 
        }

        // H√ÄM ƒê·∫æM S·ªê (ANIMATION)
        function animateScore(element, target, duration, callback) {
            let start = 0;
            let end = target;
            let startTime = null;

            if (target === 0) {
                element.innerText = 0;
                if (callback) callback();
                return;
            }

            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                let progress = Math.min((timestamp - startTime) / duration, 1);
                element.innerText = Math.floor(progress * (end - start) + start);

                if (progress < 1) {
                    window.requestAnimationFrame(step);
                } else {
                    element.innerText = end; // ƒê·∫£m b·∫£o s·ªë cu·ªëi c√πng ch√≠nh x√°c
                    if (callback) callback();
                }
            }
            
            window.requestAnimationFrame(step);
        }

        // C·∫¨P NH·∫¨T: Th√™m tham s·ªë hitByPipe ƒë·ªÉ ki·ªÉm so√°t √¢m thanh die.mp3
        function gameOver(hitByPipe) {
            gameState = 'OVER';
            const container = document.getElementById('game-container');
            container.classList.remove('shake');
            void container.offsetWidth;
            container.classList.add('shake');

            // 1. Lu√¥n ph√°t √¢m thanh Hit (va ch·∫°m) tr∆∞·ªõc d√π ch·∫°m ƒë·∫•t hay ·ªëng
            hitSound.currentTime = 0;
            hitSound.play().catch(e => console.log("Audio play blocked", e));

            // 2. Ch·ªâ ph√°t √¢m thanh Die (r∆°i) n·∫øu ch·∫°m ·ªëng (hitByPipe = true)
            // Th·ªùi gian tr·ªÖ gi·∫£m xu·ªëng 500ms
            if (hitByPipe) {
                setTimeout(() => {
                    dieSound.currentTime = 0;
                    dieSound.play().catch(e => console.log("Audio play blocked", e));
                }, 500); 
            }

            if(score > highScore) {
                highScore = score;
                localStorage.setItem('flappy_highscore', highScore);
            }

            // ·∫®n ƒëi·ªÉm s·ªë ch√≠nh
            document.getElementById('score').classList.add('hidden');
            
            // Set gi√° tr·ªã ban ƒë·∫ßu cho b·∫£ng ƒëi·ªÉm l√† 0 ƒë·ªÉ chu·∫©n b·ªã ƒë·∫øm
            const boardScoreEl = document.getElementById('board-score');
            boardScoreEl.innerText = 0; 
            document.getElementById('board-best').innerText = highScore;
            
            let medal = document.getElementById('board-medal');
            if(score >= 40) medal.innerText = "ü•á"; 
            else if(score >= 20) medal.innerText = "ü•à"; 
            else if(score >= 10) medal.innerText = "ü•â"; 
            else medal.innerText = ""; 

            const goScreen = document.getElementById('game-over-screen');
            const goTitle = document.getElementById('go-title');
            const goBoard = document.getElementById('go-board-container');
            const btnRestart = document.getElementById('btn-restart');

            goTitle.classList.remove('visible');
            goBoard.classList.remove('visible');
            btnRestart.classList.remove('visible');
            goScreen.classList.remove('hidden');

            // 1. Hi·ªán ch·ªØ Game Over
            setTimeout(() => { 
                goTitle.classList.add('visible'); 
            }, 100);

            // 2. Hi·ªán B·∫£ng ƒëi·ªÉm v√† b·∫Øt ƒë·∫ßu ƒë·∫øm s·ªë (750ms sau)
            setTimeout(() => { 
                goBoard.classList.add('visible'); 
                
                // C·∫¨P NH·∫¨T: Ph√°t √¢m thanh Swoosh khi b·∫£ng ƒëi·ªÉm hi·ªán ra
                swooshSound.currentTime = 0;
                swooshSound.play().catch(e => console.log("Audio play blocked", e));
                
                // T√≠nh to√°n th·ªùi gian ƒë·∫øm d·ª±a tr√™n ƒëi·ªÉm s·ªë (t·ªëi ƒëa 1 gi√¢y)
                let duration = Math.min(score * 50, 1000); 
                if (duration < 500) duration = 500; // T·ªëi thi·ªÉu 0.5s cho ƒë·∫πp

                animateScore(boardScoreEl, score, duration, () => {
                    // 3. Hi·ªán n√∫t Restart SAU KHI ƒë·∫øm xong
                    btnRestart.classList.add('visible');
                });

            }, 750);
        }

        function resetGame() {
            resize(); 
            document.getElementById('game-container').classList.remove('shake');
            bird.y = (GAME_HEIGHT - ground.height) / 2;
            bird.velocity = 0;
            bird.rotation = 0;
            pipes.reset();
            gameState = 'START';
            document.getElementById('game-over-screen').classList.add('hidden');
            const scoreDisplay = document.getElementById('score');
            scoreDisplay.innerText = 0;
            scoreDisplay.classList.remove('hidden');
            const startScreen = document.getElementById('start-screen');
            startScreen.classList.remove('hidden');
            startScreen.classList.remove('fade-out');
        }

        window.addEventListener('mousedown', function(e) { handleInput(); });
        window.addEventListener('touchstart', function(e) { e.preventDefault(); handleInput(); }, {passive: false});
        window.addEventListener('keydown', function(e) { if(e.code === 'Space' || e.code === 'ArrowUp') handleInput(); });

        function handleInput() {
            if(gameState === 'START') startGame();
            else if (gameState === 'PLAYING') bird.flap();
        }

        document.getElementById('btn-restart').addEventListener('click', (e) => { e.stopPropagation(); resetGame(); });
        init();
    </script>
</body>
</html>
